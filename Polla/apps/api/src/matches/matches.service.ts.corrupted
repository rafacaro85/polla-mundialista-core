import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource } from 'typeorm';
import { Match } from '../database/entities/match.entity';
import { Prediction } from '../database/entities/prediction.entity';
import { ScoringService } from '../common/scoring.service';
import { BracketsService } from '../brackets/brackets.service';
import { TournamentService } from '../tournament/tournament.service';

@Injectable()
export class MatchesService {
    constructor(
        @InjectRepository(Match)
        private matchesRepository: Repository<Match>,
        @InjectRepository(Prediction)
        private predictionsRepository: Repository<Prediction>,
        private scoringService: ScoringService,
        private dataSource: DataSource,
        private bracketsService: BracketsService,
        private tournamentService: TournamentService,
    ) { }

    async findAll(userId?: string): Promise<Match[]> {
        const query = this.matchesRepository.createQueryBuilder('match')
            .leftJoinAndSelect('match.predictions', 'prediction', 'prediction.userId = :userId', { userId })
            .orderBy('match.date', 'ASC');

        return query.getMany();
    }

    async finishMatch(matchId: string, homeScore: number, awayScore: number): Promise<Match> {
        const match = await this.matchesRepository.findOne({
            where: { id: matchId },
            relations: ['predictions']
        });

        if (!match) {
            throw new NotFoundException('Match not found');
        }

        // 1. Actualizar partido
        match.status = 'FINISHED';
        match.homeScore = homeScore;
        match.awayScore = awayScore;

        // Usamos una transacci√≥n para asegurar consistencia
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();

        try {
            await queryRunner.manager.save(match);

            // 2. Calcular puntos para todas las predicciones
            const predictionsToUpdate: Prediction[] = [];

            if (match.predictions) {
                for (const prediction of match.predictions) {
                    const points = this.scoringService.calculatePoints(
                        { homeScore: prediction.homeScore, awayScore: prediction.awayScore },
                        { homeScore, awayScore }
                    );
                    prediction.points = points;
                    predictionsToUpdate.push(prediction);
                }
            }

            // 3. Guardar predicciones actualizadas
            if (predictionsToUpdate.length > 0) {
                await queryRunner.manager.save(predictionsToUpdate);
            }

            await queryRunner.commitTransaction();

            // 4. Calcular puntos de bracket (fuera de la transacci√≥n)
            const winner = homeScore > awayScore ? match.homeTeam : match.awayTeam;
            await this.bracketsService.calculateBracketPoints(matchId, winner);
            console.log(`üèÜ Bracket points calculated for match ${matchId}, winner: ${winner}`);

            // 5. Trigger autom√°tico de promoci√≥n si es partido de grupo
            if (match.phase === 'GROUP' && match.group) {
                this.tournamentService.promoteFromGroup(match.group)
                    .catch(err => console.error(`‚ùå Error promoting from group ${match.group}:`, err));
            }

            return match;

        } catch (err) {
            await queryRunner.rollbackTransaction();
            throw err;
        } finally {
            await queryRunner.release();
        }
    }

    async updateMatch(id: string, data: any): Promise<Match> {
        const match = await this.matchesRepository.findOne({ where: { id } });
        if (!match) {
            throw new NotFoundException('Match not found');
        }

        const wasNotFinished = match.status !== 'FINISHED';

        if (data.status !== undefined) match.status = data.status;
        if (data.homeScore !== undefined) match.homeScore = data.homeScore;
        if (data.awayScore !== undefined) match.awayScore = data.awayScore;
        if (data.phase !== undefined) match.phase = data.phase;
        if (data.group !== undefined) match.group = data.group;
        if (data.homeTeamPlaceholder !== undefined) match.homeTeamPlaceholder = data.homeTeamPlaceholder;
        if (data.awayTeamPlaceholder !== undefined) match.awayTeamPlaceholder = data.awayTeamPlaceholder;
        if (data.homeTeam !== undefined) match.homeTeam = data.homeTeam;
        if (data.awayTeam !== undefined) match.awayTeam = data.awayTeam;
        if (data.date !== undefined) match.date = data.date;
        if (data.bracketId !== undefined) match.bracketId = data.bracketId;
        if (data.nextMatchId !== undefined) match.nextMatchId = data.nextMatchId;

        const savedMatch = await this.matchesRepository.save(match);

        // Calculate bracket points if match just finished
        if (wasNotFinished && match.status === 'FINISHED' &&
            match.homeScore !== null && match.awayScore !== null) {
            const winner = match.homeScore > match.awayScore ? match.homeTeam : match.awayTeam;
            await this.bracketsService.calculateBracketPoints(id, winner);
            console.log(`üèÜ Bracket points calculated for match ${id}, winner: ${winner}`);

            // Trigger autom√°tico de promoci√≥n si es partido de grupo
            if (match.phase === 'GROUP' && match.group) {
                this.tournamentService.promoteFromGroup(match.group)
                    .catch(err => console.error(`‚ùå Error promoting from group ${match.group}:`, err));
            }
        }

        return savedMatch;
    }

    async seedKnockoutMatches(): Promise<{ message: string; created: number }> {
        // Verificar si ya existen partidos de octavos
        const existingKnockout = await this.matchesRepository.count({
            where: { phase: 'ROUND_16' },
        });

        if (existingKnockout > 0) {
            return {
                message: `Ya existen ${existingKnockout} partidos de octavos. No se crearon nuevos.`,
                created: 0,
            };
        }

        const baseDate = new Date('2026-07-01T16:00:00Z');

        const knockoutMatches = [
            { homeTeamPlaceholder: '1A', awayTeamPlaceholder: '2B', phase: 'ROUND_16', bracketId: 1, date: new Date(baseDate.getTime() + 0 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1C', awayTeamPlaceholder: '2D', phase: 'ROUND_16', bracketId: 2, date: new Date(baseDate.getTime() + 0 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1E', awayTeamPlaceholder: '2F', phase: 'ROUND_16', bracketId: 3, date: new Date(baseDate.getTime() + 1 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1G', awayTeamPlaceholder: '2H', phase: 'ROUND_16', bracketId: 4, date: new Date(baseDate.getTime() + 1 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1B', awayTeamPlaceholder: '2A', phase: 'ROUND_16', bracketId: 5, date: new Date(baseDate.getTime() + 2 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1D', awayTeamPlaceholder: '2C', phase: 'ROUND_16', bracketId: 6, date: new Date(baseDate.getTime() + 2 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1F', awayTeamPlaceholder: '2E', phase: 'ROUND_16', bracketId: 7, date: new Date(baseDate.getTime() + 3 * 24 * 60 * 60 * 1000) },
            { homeTeamPlaceholder: '1H', awayTeamPlaceholder: '2G', phase: 'ROUND_16', bracketId: 8, date: new Date(baseDate.getTime() + 3 * 24 * 60 * 60 * 1000) },
        ];

        for (const matchData of knockoutMatches) {
            const match = this.matchesRepository.create({
                ...matchData,
                homeTeam: '',
                awayTeam: '',
                homeScore: null,
                awayScore: null,
                status: 'PENDING',
            });
            await this.matchesRepository.save(match);
        }

        return {
            message: `Se crearon ${knockoutMatches.length} partidos de octavos exitosamente.`,
            created: knockoutMatches.length,
        };
    }

    async resetKnockoutMatches(): Promise<{ message: string; reset: number }> {
        // Buscar todos los partidos de octavos
        const knockoutMatches = await this.matchesRepository.find({
            where: { phase: 'ROUND_16' },
        });

        if (knockoutMatches.length === 0) {
            return {
                message: 'No hay partidos de octavos para resetear.',
                reset: 0,
            };
        }

        // Mapeo de placeholders seg√∫n bracketId
        const placeholderMap: { [key: number]: { home: string; away: string } } = {
            1: { home: '1A', away: '2B' },
            2: { home: '1C', away: '2D' },
            3: { home: '1E', away: '2F' },
            4: { home: '1G', away: '2H' },
            5: { home: '1B', away: '2A' },
            6: { home: '1D', away: '2C' },
            7: { home: '1F', away: '2E' },
            8: { home: '1H', away: '2G' },
        };

        let resetCount = 0;

        for (const match of knockoutMatches) {
            const bracketId = match.bracketId || 0;
            const placeholders = placeholderMap[bracketId];

            if (placeholders) {
                match.homeTeam = '';
                match.awayTeam = '';
                match.homeTeamPlaceholder = placeholders.home;
                match.awayTeamPlaceholder = placeholders.away;
                match.homeScore = null;
                match.awayScore = null;
                match.status = 'PENDING';
                return {
                    message: `No hay partidos de octavos para resetear.',
                reset: 0,
            };
        }

        // Mapeo de placeholders seg√∫n bracketId
        const placeholderMap: { [key: number]: { home: string; away: string } } = {
            1: { home: '1A', away: '2B' },
            2: { home: '1C', away: '2D' },
            3: { home: '1E', away: '2F' },
            4: { home: '1G', away: '2H' },
            5: { home: '1B', away: '2A' },
            6: { home: '1D', away: '2C' },
            7: { home: '1F', away: '2E' },
            8: { home: '1H', away: '2G' },
        };

        let resetCount = 0;

        for (const match of knockoutMatches) {
            const bracketId = match.bracketId || 0;
            const placeholders = placeholderMap[bracketId];

            if (placeholders) {
                match.homeTeam = '';
                match.awayTeam = '';
                match.homeTeamPlaceholder = placeholders.home;
                match.awayTeamPlaceholder = placeholders.away;
                match.homeScore = null;
                match.awayScore = null;
                match.status = 'PENDING';
                await this.matchesRepository.save(match);
                resetCount++;
            }
        }

        return {
            message: `Se resetearon ${ resetCount } partidos de octavos a sus placeholders originales.`,
            reset: resetCount,
        };
    }

    /**
     * Obtiene el historial de enfrentamientos entre dos equipos (MOCK DATA)
     */
    async getHeadToHead(matchId: string) {
        const match = await this.matchesRepository.findOne({
            where: { id: matchId },
        });

        if (!match) {
            throw new NotFoundException('Match not found');
        }

        const homeTeam = match.homeTeam;
        const awayTeam = match.awayTeam;

        // MOCK DATA - En producci√≥n, esto vendr√≠a de una API externa
        const mockHistoricalMatches = [
            {
                date: '2021-07-10',
                tournament: 'Copa Am√©rica Final',
                homeTeam: homeTeam,
                awayTeam: awayTeam,
                score: '1 - 0',
                winner: homeTeam,
            },
            {
                date: '2019-11-15',
                tournament: 'Amistoso Internacional',
                homeTeam: awayTeam,
                awayTeam: homeTeam,
                score: '0 - 1',
                winner: homeTeam,
            },
            {
                date: '2018-06-16',
                tournament: 'Mundial Rusia 2018',
                homeTeam: homeTeam,
                awayTeam: awayTeam,
                score: '1 - 1',
                winner: null,
            },
        ];

        // Calcular estad√≠sticas
        const stats = {
            totalMatches: mockHistoricalMatches.length,
            homeWins: mockHistoricalMatches.filter(m => m.winner === homeTeam).length,
            awayWins: mockHistoricalMatches.filter(m => m.winner === awayTeam).length,
            draws: mockHistoricalMatches.filter(m => m.winner === null).length,
        };

        return {
            homeTeam,
            awayTeam,
            homeFlag: match.homeFlag,
            awayFlag: match.awayFlag,
            stats,
            history: mockHistoricalMatches,
        };
    }
}
